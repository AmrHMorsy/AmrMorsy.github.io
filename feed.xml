<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://amrhmorsy.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://amrhmorsy.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-24T13:39:26+00:00</updated><id>https://amrhmorsy.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Walking down the road</title><link href="https://amrhmorsy.github.io/blog/2024/Walking_down_the_road/" rel="alternate" type="text/html" title="Walking down the road"/><published>2024-11-22T12:00:00+00:00</published><updated>2024-11-22T12:00:00+00:00</updated><id>https://amrhmorsy.github.io/blog/2024/Walking_down_the_road</id><content type="html" xml:base="https://amrhmorsy.github.io/blog/2024/Walking_down_the_road/"><![CDATA[<p><br/> <br/></p> <div class="row mt-3"> <div class="col-sm-8 mx-auto text-center"> <p> Walking down the road, <br/> It’s foggy and dim. <br/> No compass for directions, <br/> No destination on the horizon. <br/><br/> Walking down the road, <br/> The Path behind me crumbles. <br/> The Path ahead of me is blurry. <br/> So no choice but to keep, <br/> walking down the road. <br/> </p> </div> </div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/s-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/s-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/s-1400.webp"/> <img src="/assets/img/s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> © 2024 Amr Morsy </div>]]></content><author><name></name></author><category term="Art"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Refraction Vector Calculation</title><link href="https://amrhmorsy.github.io/blog/2024/RefractionVectorCalculation/" rel="alternate" type="text/html" title="Refraction Vector Calculation"/><published>2024-10-31T12:00:00+00:00</published><updated>2024-10-31T12:00:00+00:00</updated><id>https://amrhmorsy.github.io/blog/2024/RefractionVectorCalculation</id><content type="html" xml:base="https://amrhmorsy.github.io/blog/2024/RefractionVectorCalculation/"><![CDATA[<p><br/></p> <h3 id="introduction-">Introduction <br/></h3> <p><br/></p> <p>When a beam of light hits the surface of an object, part of its energy is absorbed by the surface, part of its energy is reflected away and part of its energy may refract through the object itself.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/REFRACTION0-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/REFRACTION0-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/REFRACTION0-1400.webp"/> <img src="/assets/img/REFRACTION0.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>In this post, we will explore the mathematics behind calculating the refraction vector.</p> <p><br/></p> <h3 id="snell-law-">Snell Law <br/></h3> <p><br/></p> <p>Transparent surfaces has a property called the <strong>index of refraction</strong>. This refractive index determines how much the path of light is bent or refracted, when entering a material. This can be explained by <strong>Snell’s Law</strong>.</p> <p>Let:</p> <ul> <li>\(n_L\) be the index of refraction of the material the light is leaving,</li> <li>\(\theta_L\) be the angle of incidence,</li> <li>\(n_T\) be the index of refraction of the material the light is entering, and</li> <li>\(\theta_T\) be the angle of refraction.</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/REFRACTION1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/REFRACTION1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/REFRACTION1-1400.webp"/> <img src="/assets/img/REFRACTION1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>According to Snell’s Law,</p> \[n_L sin \theta_L = n_T sin \theta_T\] <p>Each material has its own unique index of refraction. For example, the index of refraction of air is <strong>1.000293</strong>, while the index of refraction of diamond is <strong>2.417</strong>. Higher indexes of refraction create a greater bending effect at the interface between two materials, causing the refraction vector to bend more towards the normal vector.</p> <p>Let:</p> <ul> <li>\(L\) be the incoming light vector,</li> <li>\(N\) be the normal vector, and</li> <li>\(T\) be the refracted light vector.</li> </ul> <p>We assume that \(L\), \(N\) and \(T\) are normalized to unit length.</p> <p><br/></p> <h3 id="decomposition-of-incoming-light-vector-l-">Decomposition of Incoming Light Vector \(L\) <br/></h3> <p><br/></p> <p>To calculate the refraction vector, we first need to decompose the incoming light vector \(L\) in relation to the surface normal vector \(N\).</p> <p>We assume that the normal vector \(N\) and the incoming light \(L\) has been normalized to unit length.</p> <p>Each vector has both a parallel component and perpendicular component relative to the normal vector \(N\).</p> <p>The parallel component of \(L\) along \(N\) is</p> \[L_{||N} = (N.L)N = N cos \theta\] <p>The perpendicular component of \(L\) along \(N\) can be calculated by subtracting \(L_{||N}\) from \(L\) . That is,</p> \[L_{⊥N} = L - L_{||N} = L - (N.L)N\] <p>Next, let’s calculate the magnitudes of \(L_{||}\) and \(L_⊥\)</p> <p>Since the vectors \(L\) , \(L_{||}\) and \(L_⊥\) form a right-angled triangle, we can use trignometric relationships to calculate their magnitudes.</p> <p>We know that</p> \[sin\theta_L = \frac{|L_⊥|}{L}\] <p>and</p> \[cos\theta_L = \frac{|L_{||}|}{L}\] <p>Since \(L\) has been normalized to unit length (i.e., \(|L| = 1\) ), then</p> \[|L_⊥| = sin \theta_L\] <p>and</p> \[|L_{||}| = cos \theta_L\] <p><br/></p> <h3 id="decomposition-of-refraction-vector-t-">Decomposition of Refraction Vector \(T\) <br/></h3> <p><br/></p> <p>Just like we did with the incoming light vector \(L\), we are going to decompose the refraction vector \(T\) in relation to the surface normal vector \(N\).</p> <p>The parallel component of \(T\) along \(N\) is</p> <p>\begin{equation} T_{||N} = (-N.T)(-N) = -N cos \theta_T \end{equation}</p> <p>As we know, we can calculate the perpendicular component of \(T\) along \(N\) as:</p> \[T_{⊥N} = T - T_{||}\] <p>However, we do not know \(T\). Hence, we must find another way to calculate \(T_{⊥N}\).</p> <p>Let’s first calculate the magnitudes of \(T_{||N}\) and \(T_{⊥N}\) .</p> <p>Since the vectors \(T\) , \(T_{||N}\) and \(T_{⊥N}\) form a right-angled triangle, we can use trignometric relationships to calculate their magnitudes.</p> <p>We know that</p> \[sin\theta_T = \frac{|T_{⊥N}|}{|T|}\] <p>and</p> \[cos\theta_T = \frac{|T_{||}|}{T}\] <p>Since \(T\) is normalized to unit length(i.e., \(|T| = 1\) . Then,</p> \[|T_{⊥N}| = sin\theta_T\] <p>Now, let’s return to the problem of calculating \(T_{⊥N}\).</p> <p>Since \(T_{⊥N}\) has the same direction as \(L_{⊥N}\), then we can calculate \(T_⊥\) as:</p> <p>\begin{equation} T_⊥ = \frac{L_{⊥N}}{|L_{⊥N}|} sin \theta_T = \frac{L-(N.L)N}{sin \theta_L} sin \theta_T \end{equation}</p> <p><br/></p> <h3 id="calculation-of-refraction-vector-t-">Calculation of Refraction Vector \(T\) <br/></h3> <p><br/></p> <p>Finally, we can calculate the refraction vector \(T\) by adding \(T_{||N}\) and \(T_{⊥N}\) . That is,</p> <p>\begin{equation} T = T_{||N} + T_{⊥N} \end{equation}</p> <p>\begin{equation} T = (-N.T)(-N) + \frac{L-(N.L)N}{sin \theta_L} sin \theta_T \end{equation}</p> <p>\begin{equation} T = -N cos \theta_T + \frac{L-(N.L)N}{sin \theta_L} sin \theta_T \end{equation}</p> <p>Let’s do some further simplification to the equation.</p> <p>We can use <strong>Snell Law</strong> to replace \(\frac{sin\theta_T}{sin\theta_L}\) with \(\frac{n_L}{n_T}\). This yields:</p> <p>\begin{equation} T = -N cos \theta_T + \frac{n_L}{n_T}(L-(N.L)N) \end{equation}</p> <p>We can also replace \(cos \theta_T\) with \(\sqrt{1-sin^2 \theta_T}\) , which gives us</p> <p>\begin{equation} T = -N \sqrt{1-sin^2 \theta_T} + \frac{n_L}{n_T}(L-(N.L)N) \end{equation}</p> <p>Furthermore, we can use <strong>Snell Law</strong> to replace \(sin^2 \theta_T\) with \(\frac{n_L^2}{n_T^2} sin^2 \theta_L\) . The result is</p> <p>\begin{equation} T = -N \sqrt{1-\frac{n_L^2}{n_T^2} sin^2 \theta_L} + \frac{n_L}{n_T}(L-(N.L)N) \end{equation}</p> <p>Finally, we can replace \(sin^2 \theta_L\) with \(1-cos^2 \theta_L = 1 - (N.L)^2\)</p> <p>This gives us:</p> <p>\begin{equation} T = -N \sqrt{1-\frac{n_L^2}{n_T^2} (1-(N.L)^2)} + \frac{n_L}{n_T}(L-(N.L)N) \end{equation}</p> <p>\begin{equation} T = -N \sqrt{1-\frac{n_L^2}{n_T^2} (1-(N.L)^2)} + \frac{n_L}{n_T}L - \frac{n_L}{n_T}(N.L)N \end{equation}</p> <p>\begin{equation} T = N ( - \frac{n_L}{n_T}(N.L) - \sqrt{1-\frac{n_L^2}{n_T^2} (1-(N.L)^2)} ) + \frac{n_L}{n_T}L \end{equation}</p> <p>The equation above of calculating the refraction vector \(T\) is only valid when</p> \[sin \theta_L \leq \frac{n_T}{n_L}\]]]></content><author><name></name></author><category term="Computer-Graphics"/><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Reflection Vector Calculation</title><link href="https://amrhmorsy.github.io/blog/2024/ReflectionVectorCalculation/" rel="alternate" type="text/html" title="Reflection Vector Calculation"/><published>2024-10-28T12:00:00+00:00</published><updated>2024-10-28T12:00:00+00:00</updated><id>https://amrhmorsy.github.io/blog/2024/ReflectionVectorCalculation</id><content type="html" xml:base="https://amrhmorsy.github.io/blog/2024/ReflectionVectorCalculation/"><![CDATA[<h3 id="introduction-">Introduction <br/></h3> <p>About a month ago, I was interviewed for a graphics programmer position. Among the questions asked was how to calculate the reflection vector of an incident light ray on a surface. Unfortunately, I was a bit nervous during the interview and couldn’t think clearly, so I couldn’t answer the question. Unsurprisingly, I didn’t get the position.</p> <p>Ironically, the solution came to mind shortly after the interview. I took some time to review the math behind it again and decided to write a blog post to break it down.</p> <p>In this post, I’ll explain the mathematics of calculating the reflection vector given an incident light vector on a surface. Let \(L\) be the incident light vector at an angle \(\theta\) from the normal, \(N\), of the surface, and \(R\) be the reflection vector of \(L\).</p> <p>Suppose \(N\) and \(L\) are normalized to unit length.</p> <p><br/></p> <h3 id="law-of-reflection-">Law of Reflection <br/></h3> <p>The law of reflection states that the angle of incidence is equal to the angle of reflection. Thus, we know that the reflection angle is also \(\theta\) from the normal, \(N\).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/D1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/D1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/D1-1400.webp"/> <img src="/assets/img/D1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <h3 id="decomposition-of-vectors-">Decomposition of Vectors <br/></h3> <p>Each vector has both parallel and perpendicular components relative to \(N\).</p> <p>The parallel component of \(L\) along \(N\) is:</p> \[L_{||} = (L.N)N\] <p>Alternatively, this can be expressed as \(N cos \theta\)</p> <p>The perpendicular component of \(L\) along \(N\) is:</p> \[L_⊥ = L - L_{||} = L - (L.N)N\] <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/D2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/D2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/D2-1400.webp"/> <img src="/assets/img/D2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <h3 id="calculating-the-reflection-vector-">Calculating the Reflection Vector <br/></h3> <p>To compute \(R\), we reverse the parallel component of \(L\) along \(N\) and keep the perpendicular component unchanged:</p> \[R = L_⊥ - L_{||}\] \[R = L - (L.N)N - (L.N)N\] \[R = L - 2 (L.N)N\] <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/D3-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/D3-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/D3-1400.webp"/> <img src="/assets/img/D3.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <h3 id="implementation-">Implementation <br/></h3> <p>Here’s the C++ code using the GLM library:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="nf">compute_reflection_vector</span><span class="p">(</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">L</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">N</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">L</span> <span class="o">-</span> <span class="mf">2.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span> <span class="p">)</span> <span class="o">*</span> <span class="n">N</span> <span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Computer-Graphics"/><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>