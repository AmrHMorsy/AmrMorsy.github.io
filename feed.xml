<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://amrhmorsy.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://amrhmorsy.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-12-24T06:13:03+00:00</updated><id>https://amrhmorsy.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Quaternions</title><link href="https://amrhmorsy.github.io/blog/2024/Quaternions/" rel="alternate" type="text/html" title="Quaternions"/><published>2024-12-01T12:00:00+00:00</published><updated>2024-12-01T12:00:00+00:00</updated><id>https://amrhmorsy.github.io/blog/2024/Quaternions</id><content type="html" xml:base="https://amrhmorsy.github.io/blog/2024/Quaternions/"><![CDATA[<p><br/></p> <h3 id="introduction-"><strong>Introduction</strong> <br/></h3> <p><br/></p> <p>In computer graphics, rotations are commonly represented using matrices. For example, a rotation by an angle \(\theta\) around the axis \(A\) is expressed using the following matrix:</p> <p><br/></p> <p>\begin{bmatrix} \cos \theta + (1 - \cos \theta) A_x^2 &amp; (1 - \cos \theta) A_x A_y - \sin \theta A_z &amp; (1- \cos \theta) A_x A_z + \sin \theta A_y \cr (1 - \cos \theta)A_x A_y + \sin \theta A_z &amp; \cos \theta + (1 - \cos \theta) A_y^2 &amp; (1- \cos \theta) A_y A_z - \sin \theta A_x \cr (1 - \cos \theta)A_x A_z - \sin \theta A_y &amp; (1 - \cos \theta) A_y A_z + \sin \theta A_x &amp; \cos \theta + ( 1 - \cos \theta ) A_z^2 \end{bmatrix}</p> <p>We can apply this rotation to a vertex by multiplying the vertex coordinates by the matrix.</p> <p>However, matrices are not the only mathematical entity to represent rotations. There is a better alternative: <strong>Quaternions</strong>.</p> <p>In this post, we will dive into the topic of quaternions. We will explore their mathematical foundations, their use in representing rotations, and how they can be more easily interpolated to produce smooth animations.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Refraction Vector Calculation</title><link href="https://amrhmorsy.github.io/blog/2024/RefractionVectorCalculation/" rel="alternate" type="text/html" title="Refraction Vector Calculation"/><published>2024-10-31T12:00:00+00:00</published><updated>2024-10-31T12:00:00+00:00</updated><id>https://amrhmorsy.github.io/blog/2024/RefractionVectorCalculation</id><content type="html" xml:base="https://amrhmorsy.github.io/blog/2024/RefractionVectorCalculation/"><![CDATA[<p><br/></p> <h3 id="introduction-"><strong>Introduction</strong> <br/></h3> <p><br/></p> <p>When a beam of light hits the surface of an object, part of its energy is absorbed by the surface, part of its energy is reflected away and part of its energy may refract through the object itself.</p> <p>In this post, we will explore the mathematics behind calculating the refraction vector.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Refraction0-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Refraction0-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Refraction0-1400.webp"/> <img src="/assets/img/Refraction0.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <p><br/></p> <h3 id="snell-law-"><strong>Snell Law</strong> <br/></h3> <p><br/></p> <p>Transparent surfaces have a property called the <strong>index of refraction</strong>. This refractive index determines how much the path of light is bent or refracted, when entering a material. This can be explained by <strong>Snell’s Law</strong>.</p> <p>Let:</p> <ul> <li>\(n_L\) be the index of refraction of the material the light is leaving,</li> <li>\(\theta_L\) be the angle of incidence,</li> <li>\(n_T\) be the index of refraction of the material the light is entering, and</li> <li>\(\theta_T\) be the angle of refraction.</li> </ul> <p>According to Snell’s Law,</p> \[n_L sin \theta_L = n_T sin \theta_T\] <p>Each material has its own unique index of refraction. For example, the index of refraction of air is <strong>1.000293</strong>, while the index of refraction of diamond is <strong>2.417</strong>. Higher indexes of refraction create a greater bending effect at the interface between two materials, causing the refraction vector to bend more towards the normal vector.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Refraction1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Refraction1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Refraction1-1400.webp"/> <img src="/assets/img/Refraction1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <p>Now, let:</p> <ul> <li>\(L\) be the incoming light vector,</li> <li>\(N\) be the normal vector, and</li> <li>\(T\) be the refracted light vector.</li> </ul> <p>We assume that \(L\), \(N\) and \(T\) are normalized to unit length.</p> <p><br/></p> <h3 id="decomposition-of-incoming-light-vector-l-">Decomposition of Incoming Light Vector \(L\) <br/></h3> <p><br/></p> <p>To calculate the refraction vector \(T\), we first need to decompose the incoming light vector \(L\) in relation to the surface normal vector \(N\).</p> <p>Each vector has both a parallel component and perpendicular component relative to the normal vector \(N\).</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Refraction2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Refraction2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Refraction2-1400.webp"/> <img src="/assets/img/Refraction2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <p>The parallel component of \(L\) along \(N\) is</p> \[L_{||N} = (N.L)N = N cos \theta\] <p>The perpendicular component of \(L\) along \(N\) can be calculated by subtracting \(L_{||N}\) from \(L\) . That is,</p> \[L_{⊥N} = L - L_{||N} = L - (N.L)N\] <p>Next, let’s calculate the magnitudes of \(L_{||N}\) and \(L_{⊥N}\)</p> <p>Since the vectors \(L\) , \(L_{||N}\) and \(L_{⊥N}\) form a right-angled triangle, we can use trignometric relationships to calculate their magnitudes.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Refraction3-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Refraction3-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Refraction3-1400.webp"/> <img src="/assets/img/Refraction3.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <p>We know that</p> \[sin\theta_L = \frac{|L_{⊥N}|}{L}\] <p>and</p> \[cos\theta_L = \frac{|L_{||N}|}{L}\] <p>Since \(L\) has been normalized to unit length (i.e., \(|L| = 1\) ), then</p> \[|L_{⊥N}| = sin \theta_L\] <p>and</p> \[|L_{||N}| = cos \theta_L\] <p><br/></p> <h3 id="decomposition-of-refraction-vector-t-"><strong>Decomposition of Refraction Vector \(T\)</strong> <br/></h3> <p><br/></p> <p>Just like we did with the incoming light vector \(L\), we are going to decompose the refraction vector \(T\) in relation to the surface normal vector \(N\).</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Refraction4-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Refraction4-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Refraction4-1400.webp"/> <img src="/assets/img/Refraction4.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <p>The parallel component of \(T\) along \(N\) is</p> \[T_{||N} = (-N.T)(-N) = -N cos \theta_T\] <p>As we know, we can calculate the perpendicular component of \(T\) along \(N\) as:</p> \[T_{⊥N} = T - T_{||}\] <p>However, we do not know \(T\). Hence, we must find another way to calculate \(T_{⊥N}\).</p> <p>Let’s first calculate the magnitudes of \(T_{||N}\) and \(T_{⊥N}\) .</p> <p>Since the vectors \(T\) , \(T_{||N}\) and \(T_{⊥N}\) form a right-angled triangle, we can use trignometric relationships to calculate their magnitudes.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Refraction5-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Refraction5-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Refraction5-1400.webp"/> <img src="/assets/img/Refraction5.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <p>We know that</p> \[sin\theta_T = \frac{|T_{⊥N}|}{|T|}\] <p>and</p> \[cos\theta_T = \frac{|T_{||}|}{T}\] <p>Since \(T\) is normalized to unit length(i.e., \(|T| = 1\) . Then,</p> \[|T_{⊥N}| = sin\theta_T\] <p>Now that we have \(|T_{⊥N}|\) , let’s return to the problem of calculating \(T_{⊥N}\) .</p> <p>Since \(T_{⊥N}\) has the same direction as \(L_{⊥N}\), then we can calculate \(T_⊥\) as:</p> \[T_⊥ = \frac{L_{⊥N}}{|L_{⊥N}|} |T_{⊥N}| = \frac{L_{⊥N}}{|L_{⊥N}|} sin \theta_T = \frac{L-(N.L)N}{sin \theta_L} sin \theta_T\] <p><br/></p> <h3 id="calculation-of-refraction-vector-t-"><strong>Calculation of Refraction Vector \(T\)</strong> <br/></h3> <p><br/></p> <p>Finally, we can calculate the refraction vector \(T\) by adding \(T_{||N}\) and \(T_{⊥N}\) . That is,</p> \[T = T_{||N} + T_{⊥N}\] \[T = (-N.T)(-N) + \frac{L-(N.L)N}{sin \theta_L} sin \theta_T\] \[T = -N cos \theta_T + \frac{L-(N.L)N}{sin \theta_L} sin \theta_T\] <p>Let’s do some further simplification to the equation.</p> <p>We can use <strong>Snell Law</strong> to replace \(\frac{sin\theta_T}{sin\theta_L}\) with \(\frac{n_L}{n_T}\). This yields:</p> \[T = -N cos \theta_T + \frac{n_L}{n_T}(L-(N.L)N)\] <p>We can also replace \(cos \theta_T\) with \(\sqrt{1-sin^2 \theta_T}\) , which gives us</p> \[T = -N \sqrt{1-sin^2 \theta_T} + \frac{n_L}{n_T}(L-(N.L)N)\] <p>Furthermore, we can use <strong>Snell Law</strong> to replace \(sin^2 \theta_T\) with \(\frac{n_L^2}{n_T^2} sin^2 \theta_L\) . The result is</p> \[T = -N \sqrt{1-\frac{n_L^2}{n_T^2} sin^2 \theta_L} + \frac{n_L}{n_T}(L-(N.L)N)\] <p>Finally, we can replace \(sin^2 \theta_L\) with \(1-cos^2 \theta_L = 1 - (N.L)^2\)</p> <p>This gives us:</p> \[T = -N \sqrt{1-\frac{n_L^2}{n_T^2} (1-(N.L)^2)} + \frac{n_L}{n_T}(L-(N.L)N)\] \[T = -N \sqrt{1-\frac{n_L^2}{n_T^2} (1-(N.L)^2)} + \frac{n_L}{n_T}L - \frac{n_L}{n_T}(N.L)N\] <p>\begin{equation} T = N ( - \frac{n_L}{n_T}(N.L) - \sqrt{1-\frac{n_L^2}{n_T^2} (1-(N.L)^2)} ) + \frac{n_L}{n_T}L \end{equation}</p> <p>Now, if you noticed, equation 1 contains a radical. If the quantity inside the radical is negative, the equation becomes invalid.</p> <p>To be more specific, equation 1 can become invalid if \(n_L &gt; n_T\) . This phenomena is called <strong>Total Internal Reflection</strong>, which means that no refraction is happening and the vector is reflecting off the surface. In this case, the equation for calculating the reflection vector is the one used.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Refraction6-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Refraction6-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Refraction6-1400.webp"/> <img src="/assets/img/Refraction6.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <p>Expressed another way, we can say that equation 1 is only valid when</p> \[sin \theta_L \leq \frac{n_T}{n_L}\] <p>Why ?</p> <p>Well, let’s prove it.</p> <p><br/></p> <h4 id="proof"><strong>Proof</strong></h4> <p><br/></p> <p>From equation 1, we can deduce that the equation becomes invalid when the quantity inside the radical becomes negative.</p> <p>Hence, equation 1 is valid only when</p> \[1-\frac{n_L^2}{n_T^2} (1-(N.L)^2) \geq 0\] <p>Rearranging the equation gives us:</p> \[\frac{n_L^2}{n_T^2} (1-(N.L)^2) \leq 1\] <p>We can divide both sides by \(\frac{n_L^2}{n_T^2}\) . This yields:</p> \[1-(N.L)^2 \leq \frac{n_T^2}{n_L^2}\] <p>Multiplying by -1 gives us:</p> \[(N.L)^2 -1 \geq - \frac{n_T^2}{n_L^2}\] \[(N.L)^2 \geq 1 - \frac{n_T^2}{n_L^2}\] <p>Now, since \(N.L = cos \theta_L\) , then</p> \[cos^2 \theta_L \geq 1 - \frac{n_T^2}{n_L^2}\] <p>We know that \(cos^2 \theta_L = 1 - sin^2 \theta_L\) . Hence,</p> \[1 - sin^2 \theta_L \geq 1 - \frac{n_T^2}{n_L^2}\] <p>Finally, rearranging the equation, multiplying by -1 and taking the square root in both sides gives us:</p> \[sin^2 \theta_L \leq \frac{n_T^2}{n_L^2}\] \[sin \theta_L \leq \frac{n_T}{n_L}\] <p>This completes the proof that equation 1 is only valid when</p> \[sin \theta_L \leq \frac{n_T}{n_L}\] <hr/> <p><br/></p> <h3 id="references">References</h3> <p><br/></p> <ul> <li>Chapter 6.4.2 - Mathematics for 3D Programming and Computer Graphics by Eric Lengyel</li> </ul> <hr/>]]></content><author><name></name></author><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Reflection Vector Calculation</title><link href="https://amrhmorsy.github.io/blog/2024/ReflectionVectorCalculation/" rel="alternate" type="text/html" title="Reflection Vector Calculation"/><published>2024-10-28T12:00:00+00:00</published><updated>2024-10-28T12:00:00+00:00</updated><id>https://amrhmorsy.github.io/blog/2024/ReflectionVectorCalculation</id><content type="html" xml:base="https://amrhmorsy.github.io/blog/2024/ReflectionVectorCalculation/"><![CDATA[<p><br/></p> <h3 id="introduction-"><strong>Introduction</strong> <br/></h3> <p><br/></p> <p>When a beam of light hits the surface of an object, part of its energy is absorbed by the surface, part of its energy is reflected away and part of its energy may refract through the object itself.</p> <p>In this post, we will explore the mathematics behind calculating the reflection vector.</p> <p><br/></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Refraction0-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Refraction0-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Refraction0-1400.webp"/> <img src="/assets/img/Refraction0.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <p>Let:</p> <ul> <li>\(L\) be the incoming light vector</li> <li>\(N\) be the normal of the surface,</li> <li>\(R\) be the reflection vector of \(L\),</li> <li>\(\theta_i\) be the angle of incidence, and</li> <li>\(\theta_r\) be the angle of reflection, and</li> </ul> <p>We assume \(N\), \(L\) and \(R\) are normalized to unit length.</p> <p><br/></p> <h3 id="law-of-reflection-"><strong>Law of Reflection</strong> <br/></h3> <p><br/></p> <p>The law of reflection states that the angle of incidence is equal to the angle of reflection. That is,</p> \[\theta_i = \theta_r\] <p><br/></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Reflection0-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Reflection0-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Reflection0-1400.webp"/> <img src="/assets/img/Reflection0.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <p><br/></p> <h3 id="decomposition-of-vector-l-"><strong>Decomposition of Vector \(L\)</strong> <br/></h3> <p><br/></p> <p>To calculate the reflection vector \(R\), we first need to decompose the incoming light vector \(L\) in relation to the surface normal vector \(N\).</p> <p>The vector \(L\) has both a parallel component relative to \(N\) ; \(L_{||N}\) and a perpendicular component relative to \(N\) ; \(L_{⊥N}\) , such that</p> \[L = L_{||N} + L_{⊥N}\] <p>The parallel component of \(L\) along \(N\) is:</p> \[L_{||N} = (L.N)N = N cos \theta\] <p>The perpendicular component of \(L\) along \(N\) can be calculated by subtracting \(L_{||N}\) from \(L\) . That is,</p> \[L_{⊥N} = L - L_{||N} = L - (L.N)N\] <p><br/></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Reflection1-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Reflection1-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Reflection1-1400.webp"/> <img src="/assets/img/Reflection1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <p>Just like we did with the incoming light vector \(L\), we are going to decompose the reflection vector \(R\) in relation to the surface normal vector \(N\).</p> <p>The vector \(R\) has both a parallel component relative to \(N\) ; \(R_{||N}\) and a perpendicular component relative to \(N\) ; \(R_{⊥N}\) , such that</p> \[R = R_{||N} + R_{⊥N}\] <p><br/></p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Reflection2-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Reflection2-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Reflection2-1400.webp"/> <img src="/assets/img/Reflection2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <p><br/></p> <h3 id="calculating-the-reflection-vector-r-"><strong>Calculating the Reflection Vector \(R\)</strong> <br/></h3> <p><br/></p> <p>Now, let’s calculate the reflection vector \(R\). Since \(R = R_{||N} + R_{⊥N}\) , then we can calculate \(R\) by calculating its components \(R = R_{||N}\) and \(R_{⊥N}\) .</p> <p>By the law of reflection, the angle of incidence is equal to the angle of reflection; i.e \(\theta_i = \theta_r\)</p> <p>This means that the components of \(R\) is equal in magnitude to the components of \(L\), but they may have opposite directions.</p> <p>The perpendicular component of \(R\) along \(N\) ; \(R_{⊥N}\) has the same direction as the perpendicular component of \(L\) along \(N\) ; \(L_{⊥N}\) .</p> <p>The parallel component of \(R\) along \(N\) ; \(R_{||N}\) , is in the opposite direction of the parallel component of \(L\) along \(N\) ; \(L_{||N}\) .</p> <p>Hence, the reflection vector \(R\) can be calculated as follows:</p> \[R = L_⊥ - L_{||}\] \[R = L - (L.N)N - (L.N)N\] \[R = L - 2 (L.N)N\] <p><br/></p> <h3 id="implementation-">Implementation <br/></h3> <p><br/></p> <p>Here’s the C++ code using the GLM library:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="nf">compute_reflection_vector</span><span class="p">(</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">L</span><span class="p">,</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">N</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">L</span> <span class="o">-</span> <span class="mf">2.0</span><span class="n">f</span> <span class="o">*</span> <span class="n">glm</span><span class="o">::</span><span class="n">dot</span><span class="p">(</span> <span class="n">L</span><span class="p">,</span> <span class="n">N</span> <span class="p">)</span> <span class="o">*</span> <span class="n">N</span> <span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <p><br/></p> <h3 id="references">References</h3> <p><br/></p> <ul> <li>Chapter 6.4.1 - Mathematics for 3D Programming and Computer Graphics by Eric Lengyel</li> </ul> <hr/>]]></content><author><name></name></author><summary type="html"><![CDATA[Introduction]]></summary></entry></feed>